<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Elasticsearch篇之分布式特性 | Jiavg</title><meta name="description" content="Elasticsearch篇之分布式特性"><meta name="keywords" content="ElasticSearch,分布式"><meta name="author" content="Jiavg"><meta name="copyright" content="Jiavg"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Elasticsearch篇之分布式特性"><meta name="twitter:description" content="Elasticsearch篇之分布式特性"><meta name="twitter:image" content="https://jiavag.github.io/img/bg/20.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Elasticsearch篇之分布式特性"><meta property="og:url" content="https://jiavag.github.io/2020/04/11/Elastic%20Search/%E7%AC%AC6%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/"><meta property="og:site_name" content="Jiavg"><meta property="og:description" content="Elasticsearch篇之分布式特性"><meta property="og:image" content="https://jiavag.github.io/img/bg/20.jpeg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://jiavag.github.io/2020/04/11/Elastic%20Search/%E7%AC%AC6%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/"><link rel="prev" title="Elasticsearch篇之深入了解Search的运行机制" href="https://jiavag.github.io/2020/04/12/Elastic%20Search/%E7%AC%AC7%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Search%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"><link rel="next" title="Elasticsearch篇之Search API" href="https://jiavag.github.io/2020/04/09/Elastic%20Search/%E7%AC%AC5%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8BSearch%20API/"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6386517046719934',
  enable_page_level_ads: 'true'
});</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.lylgjiavg.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Jiavg","link":"链接: ","source":"来源: Jiavg","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Elasticsearch篇之分布式特性"><span class="toc-number">1.</span> <span class="toc-text">Elasticsearch篇之分布式特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cerebro安装与运行"><span class="toc-number">1.1.</span> <span class="toc-text">cerebro安装与运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建集群"><span class="toc-number">1.2.</span> <span class="toc-text">构建集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动一个节点"><span class="toc-number">1.2.1.</span> <span class="toc-text">启动一个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cluster-State"><span class="toc-number">1.2.2.</span> <span class="toc-text">Cluster State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master-Node"><span class="toc-number">1.2.3.</span> <span class="toc-text">Master Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个索引"><span class="toc-number">1.2.4.</span> <span class="toc-text">创建一个索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinating-Node"><span class="toc-number">1.2.5.</span> <span class="toc-text">Coordinating Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Data-Node"><span class="toc-number">1.2.6.</span> <span class="toc-text">Data Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单点问题"><span class="toc-number">1.2.7.</span> <span class="toc-text">单点问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提高系统可用性"><span class="toc-number">1.3.</span> <span class="toc-text">提高系统可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#副本与分片"><span class="toc-number">1.3.1.</span> <span class="toc-text">副本与分片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#副本"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">副本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分片"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">分片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#副本与分片演示"><span class="toc-number">1.3.2.</span> <span class="toc-text">副本与分片演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个问题"><span class="toc-number">1.3.3.</span> <span class="toc-text">两个问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cluster-Health"><span class="toc-number">1.4.</span> <span class="toc-text">Cluster Health</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#故障转移-Failover"><span class="toc-number">1.5.</span> <span class="toc-text">故障转移 (Failover)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#文档分布式存储"><span class="toc-number">1.6.</span> <span class="toc-text">文档分布式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文档到分片的映射算法"><span class="toc-number">1.6.1.</span> <span class="toc-text">文档到分片的映射算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档创建流程"><span class="toc-number">1.6.2.</span> <span class="toc-text">文档创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档读取流程"><span class="toc-number">1.6.3.</span> <span class="toc-text">文档读取流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档批量创建的流程"><span class="toc-number">1.6.4.</span> <span class="toc-text">文档批量创建的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档批量读取的流程"><span class="toc-number">1.6.5.</span> <span class="toc-text">文档批量读取的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#脑裂问题"><span class="toc-number">1.7.</span> <span class="toc-text">脑裂问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shard详解"><span class="toc-number">1.8.</span> <span class="toc-text">Shard详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#倒排索引的不可变更"><span class="toc-number">1.8.1.</span> <span class="toc-text">倒排索引的不可变更</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档搜索实时性"><span class="toc-number">1.8.2.</span> <span class="toc-text">文档搜索实时性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#refresh"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">refresh</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#translog"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">translog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#refresh发生时机"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">refresh发生时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush发生时机"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">flush发生时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除与更新文档"><span class="toc-number">1.8.2.6.</span> <span class="toc-text">删除与更新文档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Segment-Merging"><span class="toc-number">1.8.2.7.</span> <span class="toc-text">Segment Merging</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#整体视角"><span class="toc-number">1.8.2.8.</span> <span class="toc-text">整体视角</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/bg/20.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Jiavg</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Elasticsearch篇之分布式特性</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-11 01:06:54"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-11</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-12 04:01:11"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Elastic-Stack/">Elastic Stack</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Elasticsearch篇之分布式特性"><a href="#Elasticsearch篇之分布式特性" class="headerlink" title="Elasticsearch篇之分布式特性"></a>Elasticsearch篇之分布式特性</h1><ul>
<li>es支持集群模式, 是一个分布式系统, 其好处主要有两个:<ul>
<li>增大系统容量, 如内存, 磁盘, 使得es集群可以支持PB级的数据</li>
<li>提高系统可用性, 即使部分节点停止服务, 整个集群依然可以正常服务</li>
</ul>
</li>
<li>es集群由多个es实例组成<ul>
<li>不同集群通过集群名字来区分, 可以通过 <code>cluster.name</code> 进行修改, 默认为<code>elasticsearch</code></li>
<li>每个es实例本质上是一个JVM进程, 且有自己的名字, 通过 <code>node.name</code> 进行修改</li>
</ul>
</li>
</ul>
<h2 id="cerebro安装与运行"><a href="#cerebro安装与运行" class="headerlink" title="cerebro安装与运行"></a>cerebro安装与运行</h2><ul>
<li><p>cerebro是使用Scala，Play Framework，AngularJS和Bootstrap构建的开源（MIT许可）elasticsearch Web管理工具。</p>
</li>
<li><p>github地址: <a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">https://github.com/lmenezes/cerebro</a></p>
</li>
<li><p>安装与运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">[jlc@bogon es]$ tar -zxf cerebro-0.7.2.tgz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">[jlc@bogon cerebro-0.7.2]$ bin/cerebro</span><br><span class="line">[info] play.api.Play - Application started (Prod)</span><br><span class="line">[info] p.c.s.NettyServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问cerebro</p>
<ol>
<li>在浏览器地址栏中输入<code>http://127.0.0.1:9000/</code></li>
</ol>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/2WR1LMbawmqhQ8r.jpg"  alt="2020-04-11_015107" style="zoom:50%;" />

<ol start="2">
<li><p>在Node address输入es实例的地址, 如本演示输入: ``<a href="http://127.0.0.1:9200`">http://127.0.0.1:9200`</a>, 点击connect.</p>
</li>
<li><p>接着就进入cerebro的界面, 如下图所示:</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/zkCieUKvnE8qjx3.jpg"  alt="2020-04-11_015402"></p>
</li>
</ol>
</li>
</ul>
<h2 id="构建集群"><a href="#构建集群" class="headerlink" title="构建集群"></a>构建集群</h2><h3 id="启动一个节点"><a href="#启动一个节点" class="headerlink" title="启动一个节点"></a>启动一个节点</h3><ul>
<li><p>运行如下命令可以启动一个es节点实例</p>
<ul>
<li><p>bin/elasticsearch -Ecluster.name=my_cluster -Epath.data=my_cluster_node1 -Enode.name=node1 -Ehttp.port=5200</p>
</li>
<li><p>在cerebro中输入<code>http://127.0.0.1:5200</code> 连接此节点, 显示的node节点信息如下:</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/GaJrXgjWCIKpAbM.jpg"  alt="2020-04-11_020749"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Cluster-State"><a href="#Cluster-State" class="headerlink" title="Cluster State"></a>Cluster State</h3><ul>
<li><p>es集群相关的数据称为cluster state, 主要记录以下信息:</p>
<ul>
<li><p>节点信息: 比如节点名称, 连接地址等</p>
</li>
<li><p>索引信息: 比如索引名称, 配置等</p>
</li>
<li><p>……</p>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/11/OrgsytWu5mTj3iZ.jpg"  alt="2020-04-11_022606" style="zoom:50%;" />

</li>
</ul>
</li>
</ul>
<h3 id="Master-Node"><a href="#Master-Node" class="headerlink" title="Master Node"></a>Master Node</h3><ul>
<li><p>可以修改cluster state的节点称为 master 节点, <strong>一个集群只能有一个</strong></p>
</li>
<li><p>cluster stats 存储在每个节点上, master维护最新版本并同步给其他节点</p>
</li>
<li><p>master节点是通过集群中所有节点选举产生的, 可以被选举的节点称为master-eligible节点, 相关配置如下:</p>
<ul>
<li>node.master: true    # 使此节点成为master-eligible节点</li>
</ul>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/uNF1BOZiKmnEopM.jpg"  alt="2020-04-11_023133" style="zoom: 80%;" />

</li>
</ul>
<h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><ul>
<li><p>我们通过如下api创建一个索引</p>
<ul>
<li><p>PUT test_index</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/c9WC7VNDylHY6un.jpg"  alt="2020-04-11_023655"></p>
</li>
<li><p>创建索引后, cerebro界面信息如下</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/xJm3zIj81rdawWE.jpg"  alt="2020-04-11_023655"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Coordinating-Node"><a href="#Coordinating-Node" class="headerlink" title="Coordinating Node"></a>Coordinating Node</h3><ul>
<li><p>处理请求的节点即为 Coordinating 节点, 该节点为所有节点的默认角色, 不能取消</p>
<ul>
<li>该节点负责路由请求到正确的节点处理, 比如创建索引的请求到master节点 (因为只有master节点能够修改cluster state信息)</li>
</ul>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/DRXencST4159Q6o.jpg"  alt="2020-04-11_024155" style="zoom:80%;" />

</li>
</ul>
<h3 id="Data-Node"><a href="#Data-Node" class="headerlink" title="Data Node"></a>Data Node</h3><ul>
<li><p>存储数据的节点称为data节点, 默认节点都是data类型, 相关配置如下:</p>
<ul>
<li>node.data: true</li>
</ul>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/LslWb6u7MUKwopG.jpg"  alt="2020-04-11_024503" style="zoom:80%;" />

</li>
</ul>
<h3 id="单点问题"><a href="#单点问题" class="headerlink" title="单点问题"></a>单点问题</h3><ul>
<li><p>如果node1停止服务, 则集群停止服务</p>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/kMBvp1eZu8EmTnf.jpg"  alt="2020-04-11_024704" style="zoom:80%;" />
</li>
<li><p>解决方案: 新增一个节点</p>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/52fMgajDBOXu3hS.jpg"  alt="2020-04-11_025116" style="zoom:80%;" />

<ul>
<li><p>运行如下命令可以启动一个节点实例</p>
<ul>
<li>bin/elasticsearch -Ecluster.name=my_cluster -Epath.data=my_cluster_node2 -Enode.name=node2 -Ehttp.port=6200</li>
</ul>
</li>
<li><p>运行后, cerebro显示集群状态信息如下所示</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/Ik8zAyfOEM3TQRB.jpg"  alt="2020-04-11_025302"></p>
</li>
</ul>
</li>
</ul>
<h2 id="提高系统可用性"><a href="#提高系统可用性" class="headerlink" title="提高系统可用性"></a>提高系统可用性</h2><h3 id="副本与分片"><a href="#副本与分片" class="headerlink" title="副本与分片"></a>副本与分片</h3><ul>
<li>服务可用性<ul>
<li>2个节点情况下, 允许其中一个节点停止服务</li>
</ul>
</li>
<li>数据可用性<ul>
<li>引入副本 (Replication) 解决</li>
<li>每个节点上都有完备的数据</li>
</ul>
</li>
</ul>
<h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><ul>
<li><p>如下图所示, node2上是test_index的副本</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/lZpSXmdrJLnMuGx.jpg"  alt="2020-04-11_030350"></p>
</li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><ul>
<li><p>引入分片是为了增大系统容量</p>
</li>
<li><p>如何将数据分布于所有节点上?</p>
<ul>
<li>引入分片 (Shard) 解决问题</li>
</ul>
</li>
<li><p>分片是es支持PB级数据的基石</p>
<ul>
<li>分片存储了部分数据, 可以分布于任意节点上</li>
<li>分片数在索引创建时指定且后续不允许再更改, 默认为5个</li>
<li>分片有主分片和副本分片之分, 以实现数据的高可用</li>
<li>副本分片的数据由主分片同步, 可以有多个, 从而提高读取的吞吐量</li>
</ul>
</li>
<li><p>下图演示的是3个节点的集群中test_index的分片分布情况, 创建时我们制定了3个分片和一个副本, api如下所示:</p>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/DXFhTqVaGv5z27b.jpg"  alt="2020-04-11_031143" style="zoom: 80%;" />

</li>
</ul>
<h3 id="副本与分片演示"><a href="#副本与分片演示" class="headerlink" title="副本与分片演示"></a>副本与分片演示</h3><ul>
<li><p>我们将要构建一个如下图所示的es集群</p>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/JKZRzg1ac6eWQLI.jpg"  alt="2020-04-11_031143" style="zoom: 80%;" />
</li>
</ul>
<ol>
<li><p>启动三个es节点实例, 一个作为master节点, 另外两个作为data节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node1</span></span><br><span class="line">[jlc@localhost elasticsearch-6.1.1]$ bin/elasticsearch -Ecluster.name=my_cluster -Epath.data=my_cluster_node1 -Enode.name=node1 -Ehttp.port=5200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node2</span></span><br><span class="line">[jlc@localhost elasticsearch-6.1.1]$ bin/elasticsearch -Ecluster.name=my_cluster -Epath.data=my_cluster_node2 -Enode.name=node2 -Ehttp.port=6200</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node3</span></span><br><span class="line">[jlc@localhost elasticsearch-6.1.1]$ bin/elasticsearch -Ecluster.name=my_cluster -Epath.data=my_cluster_node3 -Enode.name=node3 -Ehttp.port=7200</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建test_shard_replic索引, 并设置副本为1, 分片数为3 (其中在cerebro中创建方式如下)</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/JtRSw1n87oTQZKD.jpg"  alt="2020-04-11_032728"></p>
</li>
<li><p>创建完毕后, cerebro显示的集群状态如下图所示</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/3tM7ZboysFwCgGN.jpg"  alt="2020-04-11_032728"></p>
<p>注: 如果磁盘空间太小, es默认不能分配, 需要修改如下配置进行分配</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/XJxWflHC2OgIG9A.jpg"  alt="2020-04-11_032728"></p>
</li>
</ol>
<h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ul>
<li><p>提出两个问题的当前es集群状态如下:</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/NIPHtgxXbSAC4hO.jpg"  alt="2020-04-11_033853"></p>
</li>
</ul>
<ol>
<li><p>此时增加节点是否能够提高test_index的数据容量?</p>
<ul>
<li>不能, 因为只有3个分片, 已经分布在3台节点上, 新增的节点无法利用</li>
<li>新增一个节点后, 集群状态如下</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/j3elk5ZPVqGnUhr.jpg"  alt="2020-04-11_034135"></p>
</li>
<li><p>此时增加副本数是否能够提高test_index的读取吞吐量?</p>
<ul>
<li>不能, 因为新增的副本也是分布在这3个节点上, 还是利用了同样的资源, 如果要增加吞吐量, 还需要新增节点.</li>
<li>新增副本数, 集群状态如下</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/dUAQ4GqI6oOm1vr.jpg"  alt="2020-04-11_034444"></p>
</li>
</ol>
<ul>
<li>分片数的设定很重要, 需要提前规划好<ul>
<li>过小导致后续无法通过增加节点实现水平扩容</li>
<li>过大会导致一个节点上分布过多的分片, 造成资源浪费, 同时会影响查询性能</li>
</ul>
</li>
</ul>
<h2 id="Cluster-Health"><a href="#Cluster-Health" class="headerlink" title="Cluster Health"></a>Cluster Health</h2><ul>
<li><p>通过如下api 可以查看集群状况, 包括以下三种:</p>
<ul>
<li>green   健康状态, 值所有的主副分片都正常分配</li>
<li>yellow  指所有的主分片都正常分配, 但是有副本分片未正常分配</li>
<li>red       有主分片未分配</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">  #</span><span class="bash"> request</span></span><br><span class="line">  GET /_cluster/health</span><br><span class="line">  </span><br><span class="line"><span class="meta">  #</span><span class="bash"> response</span></span><br><span class="line">&#123;</span><br><span class="line">    "cluster_name": "my_cluster",</span><br><span class="line">    "status": "green",</span><br><span class="line">    "timed_out": false,</span><br><span class="line">    "number_of_nodes": 3,</span><br><span class="line">    "number_of_data_nodes": 3,</span><br><span class="line">    "active_primary_shards": 3,</span><br><span class="line">    "active_shards": 6,</span><br><span class="line">    "relocating_shards": 0,</span><br><span class="line">    "initializing_shards": 0,</span><br><span class="line">    "unassigned_shards": 0,</span><br><span class="line">    "delayed_unassigned_shards": 0,</span><br><span class="line">    "number_of_pending_tasks": 0,</span><br><span class="line">    "number_of_in_flight_fetch": 0,</span><br><span class="line">    "task_max_waiting_in_queue_millis": 0,</span><br><span class="line">    "active_shards_percent_as_number": 100</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h2 id="故障转移-Failover"><a href="#故障转移-Failover" class="headerlink" title="故障转移 (Failover)"></a>故障转移 (Failover)</h2><ul>
<li><p>集群由3个节点组成, 如下所示, 此时集群状态是green</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/HwTrRdayiQBWMh9.jpg"  alt="2020-04-11_041054"></p>
</li>
<li><p>node1所在机器宕机导致服务终止, 此时集群会如何处理?</p>
<ol>
<li><p>node2和node3发现node1无法响应一段时间后会发起master选举, 比如这里选择node2为master节点. 此时由于主分片PO下线, 集群状态变为Red</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/pTCh9DcBMlojmPX.jpg"  alt="2020-04-11_041349"></p>
</li>
<li><p>node2发现主分片P0未分配, 将R0提升为主分片. 此时由于所有主分片都正常分配, 集群变为yellow</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/GTKuZf7CbdvIPkJ.jpg"  alt="2020-04-11_041541"></p>
</li>
<li><p>node2为P0和P1生成新的副本, 集群状态变为green</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/Sg4weCNhW6VLGTj.jpg"  alt="2020-04-11_041656"></p>
</li>
</ol>
</li>
</ul>
<h2 id="文档分布式存储"><a href="#文档分布式存储" class="headerlink" title="文档分布式存储"></a>文档分布式存储</h2><ul>
<li><p>当用户发起一个PUT请求, 文档最终会存储在分片上, 如下图所示:</p>
<ul>
<li>假设Document1 最终存储在分片P1上</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/xwuEyjW97TL8kMF.jpg"  alt="2020-04-11_043043"></p>
</li>
<li><p>Document1是如何存储到分片P1的? 选择P1的依据是什么?</p>
<ul>
<li>需要文档到分片的映射算法</li>
<li>目的<ul>
<li>使得文档均匀分布在所有的分片上, 以充分利用资源</li>
</ul>
</li>
<li>算法<ul>
<li>随机选择或者round-robin算法?<ul>
<li>不可取, 因为需要维护文档到分片的映射关系, 成本巨大</li>
</ul>
</li>
<li>根据文档实时计算对应的分片才是可取之道</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="文档到分片的映射算法"><a href="#文档到分片的映射算法" class="headerlink" title="文档到分片的映射算法"></a>文档到分片的映射算法</h3><ul>
<li>es通过如下的公式计算文档对应的分片<ul>
<li>shard = hash(routing) % number_of_primary_shards</li>
<li>hash算法保证可以将数据均匀的分散在分片中</li>
<li>routing是一个关键参数, 默认是文档的id, 也可以自行制定</li>
<li>number_of_primary_shards是主分片数</li>
</ul>
</li>
<li>该算法与主分片数相关, 这也是<strong>分片数一旦确定后便不能更改</strong>的原因</li>
</ul>
<h3 id="文档创建流程"><a href="#文档创建流程" class="headerlink" title="文档创建流程"></a>文档创建流程</h3><ol>
<li>Client向node3发起创建文档的请求</li>
<li>node3通过routing计算该文档应该存储到Shard1上, 查询cluster state 后确认主分片P1在node2上, 然后转发创建文档的请求到node2上</li>
<li>P1接收并执行创建文档请求后, 将同样的请求发送到副本分片R1</li>
<li>R1接收并执行创建文档请求后, 通知P1成功的结果</li>
<li>P1接收副本分片结果后, 通知node3创建成功</li>
<li>node3返回结果到Client</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/XYIWA1O4kNUDRo7.jpg"  alt="2020-04-11_044328"></p>
<h3 id="文档读取流程"><a href="#文档读取流程" class="headerlink" title="文档读取流程"></a>文档读取流程</h3><ol>
<li>Client向node3发起获取文档1的请求</li>
<li>node3通过routing计算该文档在Shard1上, 查询cluster state后获取Shard1的主副分片列表, 然后以轮训的机制获取一个shard, 比如这里是R1, 然后转发读取文档的请求到node1</li>
<li>R1接收并执行读取文档请求后, 将结果返回node3</li>
<li>node3返回结果给Client</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/t4LEAxkdQMHf9Cm.jpg"  alt="2020-04-11_044744"></p>
<h3 id="文档批量创建的流程"><a href="#文档批量创建的流程" class="headerlink" title="文档批量创建的流程"></a>文档批量创建的流程</h3><ol>
<li>Client向node3发起批量创建文档的请求(bulk)</li>
<li>node3通过routing计算所有文档对应的shard, 然后按照主shard分配对应执行的操作, 同时发送请求到涉及的主shard, 比如这里3个主shard都需要参与</li>
<li>主shard接收并执行请求后, 将同样的请求同步到对应的副本shard</li>
<li>副本shard执行结果后返回结果到主shard, 主shard再返回node3</li>
<li>node3整合结果后返回Client</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/uNdhzB7439pMqIw.jpg"  alt="2020-04-11_045350"></p>
<h3 id="文档批量读取的流程"><a href="#文档批量读取的流程" class="headerlink" title="文档批量读取的流程"></a>文档批量读取的流程</h3><ol>
<li>Client向node3发起批量获取文档的请求(mget)</li>
<li>node3通过routing计算所有文档对应的shard, 然后轮训的机制获取需要参与的shard, 按照shard构建mget请求同时发送请求到设计的shard, 比如这里有两个shard需要参与</li>
<li>R1, R2返回文档结果给node3</li>
<li>node3返回结果给Client</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/4cXmTPFRSqxvgps.jpg"  alt="2020-04-11_045822"></p>
<h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><ul>
<li><p>脑裂问题, 英文名为split-brain, 是分布式系统中的经典网络问题, 如下图所示:</p>
<ul>
<li><p>3个节点组成的集群, 突然node1的网络和其他两个节点中断</p>
<p>node2与node3会重新选举master, 比如node2成为了新的master, 此时会更新cluster state</p>
<p>node1自己组成集群后, 也会更新cluster state</p>
<p>同一个集群有两个master, 而且维护不同的cluster state, 网络恢复后无法选择正确的master</p>
</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/vzIQJcNKgGo3B8e.jpg"  alt="2020-04-11_050815"></p>
</li>
<li><p>解决方案: 仅在可选举master-eligible节点数大于等于quorum时才可以进行master选举</p>
<ul>
<li>quorum = master-eligible节点数/2 + 1, 例如3个master-eligible节点时, quorum为2.</li>
<li>设定discovery.zen.minimum_master_nodes 为quorum即可避免脑裂</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/qh3UNlJIoWwQxjc.jpg"  alt="2020-04-11_051200"></p>
</li>
</ul>
<h2 id="Shard详解"><a href="#Shard详解" class="headerlink" title="Shard详解"></a>Shard详解</h2><h3 id="倒排索引的不可变更"><a href="#倒排索引的不可变更" class="headerlink" title="倒排索引的不可变更"></a>倒排索引的不可变更</h3><ul>
<li><p>倒排索引一旦生成, 不能更改</p>
<ul>
<li>其好处如下:<ul>
<li>不用考虑并发写文件的考虑, 杜绝了锁机制带来的性能问题</li>
<li>由于文件不再更改, 可以充分利用文件系统缓存, 只需载入一次, 只要内存足够, 对该文件的读取都会从内存读取, 性能高</li>
<li>利于生成缓存数据</li>
<li>利于对文件进行压缩存储, 节省磁盘和内存存储空间</li>
</ul>
</li>
<li>坏处为需要写入新文档时, 必须重新构建倒排索引文件, 然后替换掉老文件后, 新文档才能被检索, 导致文档实时性差, 如下图所示:</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/QY8Inb5gMikWX4q.jpg"  alt="2020-04-11_053130"></p>
<ul>
<li>为此, 一个解决方案为, 生成一个新的倒排索引文件,在用户进行查询时, 同时查询这”两个”倒排索引文件, 然后结合结果返回给用户, 如下图所示:</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/OgKfyoRB5vzhVba.jpg"  alt="2020-04-11_053354"></p>
</li>
</ul>
<h3 id="文档搜索实时性"><a href="#文档搜索实时性" class="headerlink" title="文档搜索实时性"></a>文档搜索实时性</h3><ul>
<li>Lucene便是采用了上述方案, 它构建的单个倒排索引文件称为segment, 合在一起称为Index, 与ES中的Index概念不同. ES中的一个Shard对应一个Lucene Index.</li>
<li>Lucene会有一个专门的文件来记录所有的segment信息, 称为commit point.</li>
</ul>
<img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/OT1YmopuyM2glWA.jpg"  alt="2020-04-11_053737" style="zoom:80%;" />

<h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h4><ul>
<li>segment写入磁盘的过程依然很耗时, 可以借助文件系统缓存的特性, 先将segment在缓存中创建并开放查询来进一步提升实时性, 该过程在es中称为refresh.</li>
<li>在refresh之前文档会先存储在一个buffer中, refresh时将buffer中的所有文档清空并生成segment.</li>
<li>es默认每一秒执行一次refresh, 因此文档的实时性被提高到一秒, 这也是es被称为近实时(Near Real Time)的原因.</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/Ke4c9mts2LkoZvX.jpg"  alt="2020-04-11_054400"></p>
<h4 id="translog"><a href="#translog" class="headerlink" title="translog"></a>translog</h4><ul>
<li><p>如果在内存中的segment还没有写入磁盘前发生了宕机, n那么其中的文档就无法恢复了, 如何解决这个问题?</p>
<ul>
<li>es引入了translog机制. 写入文档到buffer时, 同时将该操作写入translog.</li>
<li>translog文件会即时写入磁盘(fsync), 6.x默认每个请求都会落盘, 可以修改为每5秒写一次, 这样的风险便是丢失5秒内的数据, 相关配置为index.translog.*</li>
<li>es启动时会检查translog文件, 并从中恢复</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/DEjspCvahQtOMWg.jpg"  alt="2020-04-11_055016"></p>
</li>
</ul>
<h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><ul>
<li><p>flush负责将内存中的segment写入磁盘, 主要做如下的工作:</p>
<ul>
<li>将translog写入磁盘</li>
<li>将index buffer清空, 其中的文档生成一个新的segment, 相当于一个refresh操作</li>
<li>更新commit point并写入磁盘</li>
<li>执行fsync操作, 将内存中的segment写入磁盘</li>
<li>删除旧的translog文件</li>
</ul>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/p9NLoqShJO18uVA.jpg"  alt="2020-04-11_055501"></p>
</li>
</ul>
<h4 id="refresh发生时机"><a href="#refresh发生时机" class="headerlink" title="refresh发生时机"></a>refresh发生时机</h4><ul>
<li>refresh发生的时机主要有如下几种情况:<ul>
<li>间隔时间达到时, 通过index.settings.refresh_interval来设定, 默认是1秒</li>
<li>index.buffer占满时, 其大小通过indices.memory.index_buffer_size设置, 默认为jvm heap的10%, 所有shard共享</li>
<li>flush发生时也会发生refresh</li>
</ul>
</li>
</ul>
<h4 id="flush发生时机"><a href="#flush发生时机" class="headerlink" title="flush发生时机"></a>flush发生时机</h4><ul>
<li>flush发生的时机主要有如下几种情况:<ul>
<li>间隔时间达到时,默认是30分钟, 5.x之前可以通过index.translog.fresh_threshold_period修改, 之后无法修改.</li>
<li>translog占满时, 其大小可以通过indices.translog.fresh_threshold_size控制, 默认为512mb, 每个index有自己的translog.</li>
</ul>
</li>
</ul>
<h4 id="删除与更新文档"><a href="#删除与更新文档" class="headerlink" title="删除与更新文档"></a>删除与更新文档</h4><ul>
<li>segment一旦生成就不能修改, 那么如果你要删除文档该如何操作?<ul>
<li>Lucene专门维护一个.del的文件, 记录已经删除的文档, 注意.del上记录的是文档在Lucene内部的id</li>
<li>在查询结果返回前会过滤掉.del中的所有文档</li>
</ul>
</li>
<li>更新文档如何进行呢?<ul>
<li>首先删除文档, 然后再创建新文档</li>
</ul>
</li>
</ul>
<h4 id="Segment-Merging"><a href="#Segment-Merging" class="headerlink" title="Segment Merging"></a>Segment Merging</h4><ul>
<li>随着segment的增多, 由于一次查询的segment数增多, 查询速度会变慢</li>
<li>es会定时在后台进行segment merge的操作, 减少segment的数量</li>
<li>通过force_merge api可以手动强制做segment merge的操作</li>
</ul>
<h4 id="整体视角"><a href="#整体视角" class="headerlink" title="整体视角"></a>整体视角</h4><ul>
<li><p>Lucene Index与ES Index的术语对照如下所示:</p>
<p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/04/12/atAb7QN35hZrw21.jpg"  alt="2020-04-11_060717"></p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jiavg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jiavag.github.io/2020/04/11/Elastic%20Search/%E7%AC%AC6%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/">https://jiavag.github.io/2020/04/11/Elastic%20Search/%E7%AC%AC6%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jiavag.github.io" target="_blank">Jiavg</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ElasticSearch/">ElasticSearch</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/17.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.png" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/12/Elastic%20Search/%E7%AC%AC7%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Search%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"><img class="prev_cover lazyload" data-src="/img/bg/18.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Elasticsearch篇之深入了解Search的运行机制</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/09/Elastic%20Search/%E7%AC%AC5%E7%AB%A0-Elasticsearch%E7%AF%87%E4%B9%8BSearch%20API/"><img class="next_cover lazyload" data-src="/img/bg/18.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Elasticsearch篇之Search API</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/01/Elastic Search/1.ElasticSearch与Kibana/" title="ElasticSearch与Kibana入门"><img class="relatedPosts_cover lazyload"data-src="/img/bg/17.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-01</div><div class="relatedPosts_title">ElasticSearch与Kibana入门</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/09/Elastic Search/第4章-Elasticsearch篇之Mapping设置/" title="Elasticsearch篇之Mapping设置"><img class="relatedPosts_cover lazyload"data-src="/img/bg/7.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-09</div><div class="relatedPosts_title">Elasticsearch篇之Mapping设置</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/12/Elastic Search/第8章-Elasticsearch篇之聚合分析入门/" title="Elasticsearch篇之聚合分析入门"><img class="relatedPosts_cover lazyload"data-src="/img/bg/8.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-12</div><div class="relatedPosts_title">Elasticsearch篇之聚合分析入门</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/12/Elastic Search/第7章-Elasticsearch篇之深入了解Search的运行机制/" title="Elasticsearch篇之深入了解Search的运行机制"><img class="relatedPosts_cover lazyload"data-src="/img/bg/18.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-12</div><div class="relatedPosts_title">Elasticsearch篇之深入了解Search的运行机制</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/08/Elastic Search/第3章-Elasticsearch篇之倒排索引与分词/" title="Elasticsearch篇之倒排索引与分词"><img class="relatedPosts_cover lazyload"data-src="/img/bg/10.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-08</div><div class="relatedPosts_title">Elasticsearch篇之倒排索引与分词</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/09/Elastic Search/第5章-Elasticsearch篇之Search API/" title="Elasticsearch篇之Search API"><img class="relatedPosts_cover lazyload"data-src="/img/bg/18.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-09</div><div class="relatedPosts_title">Elasticsearch篇之Search API</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Jiavg</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>